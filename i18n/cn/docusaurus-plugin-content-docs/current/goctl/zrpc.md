# rpc 指令

Goctl Rpc是`goctl`脚手架下的一个rpc服务代码生成模块，支持proto模板生成和rpc服务代码生成，通过此工具生成代码你只需要关注业务逻辑编写而不用去编写一些重复性的代码。这使得我们把精力重心放在业务上，从而加快了开发效率且降低了代码出错率。

## 特性

* 简单易用
* 快速提升开发效率
* 出错率低
* 贴近protoc


## 快速开始

### 方式一：快速生成greet服务

通过命令 `goctl rpc new ${servieName}`生成

如生成greet rpc服务：

  ```shell
  $ goctl rpc new greet
  ```

执行后代码结构如下:

```shell
cd greet && tree
.
├── etc
│   └── greet.yaml
├── go.mod
├── go.sum
├── greet
│   ├── greet.go
│   ├── greet.pb.go
│   └── greet_grpc.pb.go
├── greet.go
├── greet.proto
└── internal
    ├── config
    │   └── config.go
    ├── logic
    │   └── pinglogic.go
    ├── server
    │   └── greetserver.go
    └── svc
        └── servicecontext.go
  ```

:::tip
新版本目录详见 [rpc目录](../design/rpc-dir)
:::

### 方式二：通过指定proto生成rpc服务

* 生成proto模板

  ```shell
  $ goctl rpc template --o=user.proto
  ```

  ```protobuf
  syntax = "proto3";
  
  package user;
  option go_package="./user";
  
  message Request {
    string ping = 1;
  }
  
  message Response {
    string pong = 1;
  }
  
  service User {
    rpc Ping(Request) returns(Response);
  }
  ```

* 生成rpc服务代码
  ```shell
  $ goctl rpc protoc user.proto --go_out=. --go-grpc_out=. --zrpc_out=.
  ```


## 准备工作
* 安装了go环境
* 安装了protoc & protoc-gen-go，并且已经设置环境变量
* 更多问题请见 <a href="#注意事项">注意事项</a>

## 用法

### rpc服务生成用法

```shell
$ goctl rpc protoc -h
NAME:
   goctl rpc protoc - generate grpc code

USAGE:
   example: goctl rpc protoc xx.proto --go_out=./pb --go-grpc_out=./pb --zrpc_out=.

DESCRIPTION:
   for details, see https://go-zero.dev/cn/goctl-rpc.html

OPTIONS:
   --zrpc_out value  the zrpc output directory
   --style value     the file naming format, see [https://github.com/zeromicro/go-zero/tree/master/tools/goctl/config/readme.md]
   --home value      the goctl home path of the template
   --remote value    the remote git repo of the template, --home and --remote cannot be set at the same time, if they are, --remote has higher priority
                     The git repo directory must be consistent with the https://github.com/zeromicro/go-zero-template directory structure
   --branch value    the branch of the remote repo, it does work with --remote
   --verbose, -v     enable log output
```

你可以理解为 zrpc 代码生成是用 `goctl rpc $protoc_command --zrpc_out=${output}` 模板，如原来生成 grpc 代码指令为
```shell
$ protoc user.proto --go_out=. --go-grpc_out=.
```
则生成 zrpc 代码指令就为
```shell
$ goctl rpc protoc user.proto --go_out=. --go-grpc_out=. --zrpc_out=.
```

:::tip

1. --go_out 与 --go-grpc_out 生成的最终目录必须一致
2. --go_out & --go-grpc_out 和 --zrpc_out 的生成的最终目录必须不为同一目录，否则pb.go和_grpc.pb.go就与main函数同级了，这是不允许的。
--go_out 与 --go-grpc_out 生产的目录会受 --go_opt 和 --grpc-go_opt 和proto源文件中 go_package值的影响，要想理解这里的生成逻辑，建议阅读
官方文文档：[Go Generated Code](https://developers.google.com/protocol-buffers/docs/reference/go-generated)
:::

### 开发人员需要做什么

关注业务代码编写，将重复性、与业务无关的工作交给goctl，生成好rpc服务代码后，开发人员仅需要修改

* 服务中的配置文件编写(etc/xx.json、internal/config/config.go)
* 服务中业务逻辑编写(internal/logic/xxlogic.go)
* 服务中资源上下文的编写(internal/svc/servicecontext.go)


### 注意事项

* proto暂不支持多文件同时生成
* proto不支持外部依赖包引入，message不支持inline
* 目前main文件、shared文件、handler文件会被强制覆盖，而和开发人员手动需要编写的则不会覆盖生成，这一类在代码头部均有

  ``` shell
  // Code generated by goctl. DO NOT EDIT!
  // Source: xxx.proto
  ```

  的标识，请注意不要在里面写业务性代码;也不要将它写在业务性代码里面。

## proto import
* 对于rpc中的requestType和returnType必须在main proto文件定义，对于proto中的message可以像protoc一样import其他proto文件。

proto示例:

### 错误import
```protobuf
syntax = "proto3";

package greet;

option go_package = "./greet";

import "base/common.proto";

message Request {
  string ping = 1;
}

message Response {
  string pong = 1;
}

service Greet {
  rpc Ping(base.In) returns(base.Out);// request和return 不支持import
}

```


### 正确import
```protobuf
syntax = "proto3";

package greet;

option go_package =  "./greet";

import "base/common.proto";

message Request {
  base.In in = 1;// 支持import
}

message Response {
 base.Out out = 2;// 支持import
}

service Greet {
  rpc Ping(Request) returns(Response);
}
```
